# DataStructure / lzyclass

本目录下存放`lzystructure`文件夹下所对应编写的C++类文件实现。


## Introduction:

学习数据结构的源码封装分享，提高学习效率

包含可直接运行的实例，C和C++实现的各种数据结构头文件封装，一些常用的小函数功能

学习数据结构本身很辛苦，就让我们一起从中寻找快乐吧！



##### 想法来源

> 在学习数据结构的课程中，学习线性表、链表、栈和队列等时，
几乎进行任何操作都要经过 定义结构->创建->初始化 ，可能此时不同结构时就会新建一堆不同的main文件
于是就想：何不写成头文件把固定的方法包装好

本文件是开发文档，抛砖引玉除了书上所写之外还可以做什么

当然是让代码写的更优雅了

其他介绍描述详见：[Github:CDataStructure](https://github.com/Cangqifeng/CDataStructure)



## 开发指南：

除了完成对数据结构的基本操作外，我们还可以考虑：

> 如何让代码写的更优雅~

#### 封装成类

通过简单使用类的特性简化操作。

可以做以下处理：

最初：每写一个新的函数功能都需要做声明
使用类：直接写到类的方法下，无需声明即可使用，简洁明了。

最初：每次定义结构后需要初始化，用完后再销毁释放
使用类：放到类的构造函数中一次完成，析构函数中自动销毁，省事儿。

最初：每次调用函数处理结构需要传入 结构实例指针或者引用
使用类：将结构实例保存为属性，函数内使用 `this` 指针访问，节省一个参数，优美。

此外，通过指正访问类对象，并对内部无需输出的方法改造返回当前自身指针，就能使用链式调用，让调用像糖葫芦一样连贯，简直不能再优雅了！



#### 扩展方法使其更灵活

首先可以重载一些函数，修改参数和返回值类型来让使用更方便。

如：

- 对于书本上的：`deleteElem(int index, ElemType &el)`，我们重载一个`deleteElem(int index)`，我们并不一定需要获得接收删除元素后的返回值，就无需强制调用时输入一个输出型参数。当然，如果需要，可以将函数定义成`ElemType`型，将删除的值返回出去。


- 对于书本上的：`getElem`,`deleteElem`和`insertElem`等，其实现默认当index为负数时就被判定为不合法直接结束return了。但其实，我们可以修改它成负数就从末尾计数，如：-1 表示最后一个元素（第一个元素为零），-2表示倒数第二个元素，……，超出长度的 -xx 才报错返回



#### 实现额外的函数

除了一些简单的重载使之使用更方便，
考察实际使用和模仿一些高级语言通用的方法,
我们打算为每个数据结构实现下列方法：

| 函数/方法名             | 描述                                 |
| :---------------------- | :----------------------------------- |
| randomInit(int n)       | 随机初始化所有内容或者前n个          |
| reverse                 | 逆序结构                             |
| indexOf(ElemType e)     | 查找元素，同 `locateElem` 从左边开始 |
| lastIndexOf(ElemType e) | 类 `indexOf` 从右边开始的查找        |


**完成了以上看似繁琐却受益无穷的修改操作，看看你是不是对这些数据结构的掌握又加深了一层？**


### 其他展望

**Q:** 实现了这个之后，我们能真正直接把它拿来使用嘛？比如做为存储一个班的学生信息。节点的结构体类似下面：

```C
struct Student{
    int id;
    char *name;
    char *className;
    ……
}
typedef Student ElemType;
```

**A:** 还是不能，默认的ElemType为整型，实现中简化了很多操作，真正使用还是需要对各函数进行修改。除非现在定义成虚函数，定义需要根据ElemType结构来实现的各种比较的虚函数，这样可以很快的根据自定义的结构体简单实现基本比较等运算就可以拿来使用了，成为一个真正“有用的”头文件。知识有限，暂时只想到这种方法，不知道有没有更好的解决方式。
